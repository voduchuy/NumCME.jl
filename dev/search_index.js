var documenterSearchIndex = {"docs":
[{"location":"api/models/#CME-models","page":"CME models","title":"CME models","text":"","category":"section"},{"location":"api/models/","page":"CME models","title":"CME models","text":"Modules = [NumCME]\nPages = [\"cmemodel.jl\"]","category":"page"},{"location":"api/models/#NumCME.CmeModel","page":"CME models","title":"NumCME.CmeModel","text":"Stochastic reaction network model.\n\nFields\n\nstoich_matrix::Matrix{IntT}\n\n(Net) stoichiometry matrix. Column i represents the net change to molecular counts due to reaction i.\n\npropensities::Vector{PT}\n\nPropensity functions. \n\nparameters::AbstractVector\n\nParameters.\n\nExamples\n\nThe following code constructs a CmeModel instance for the two-state telegraphic gene expression model.\n\nùïä = [[-1, 1, 0] [1, -1, 0] [0, 0, 1] [0, 0, -1]] # Net stoichiometry matrix for 3 species `inactive_gene`, `activated_gene`, `mRNA`\na1 = propensity() do x, p\n    p[1] * x[1]\nend\na2 = propensity() do x, p\n    p[2] * x[2]\nend\na3 = propensity() do x, p\n    p[3] * x[2]\nend\na4 = propensity() do x, p\n    p[4] * x[3]\nend\nk‚ÇÄ‚ÇÅ = 0.05\nk‚ÇÅ‚ÇÄ = 0.1\nŒª = 5.0\nŒ≥ = 0.5\nŒ∏ = [k‚ÇÄ‚ÇÅ, k‚ÇÅ‚ÇÄ, Œª, Œ≥]\nmodel = CmeModel(ùïä, [a1,a2,a3,a4], Œ∏)\n\nSee also\n\nCmeModelWithSensitivity, Propensity, StandardTimeInvariantPropensity, JointTimeVaryingPropensity, SeparableTimeVaryingPropensity.\n\n\n\n\n\n","category":"type"},{"location":"api/models/#NumCME.CmeModelWithSensitivity","page":"CME models","title":"NumCME.CmeModelWithSensitivity","text":"CmeModelWithSensitivity\n\nStochastic reaction network model with information about gradient of the propensity functions with respect to parameters. \n\nSee also\n\nPropensityGradient\n\n\n\n\n\n","category":"type"},{"location":"api/models/#NumCME.CmeModelWithSensitivity-Tuple{CmeModel}","page":"CME models","title":"NumCME.CmeModelWithSensitivity","text":"CmeModelWithSensitivity(model::CmeModel)\n\nConstruct a CME model with sensitivity from a CME model (without sensitivity information) using ForwardDiff.jl automatic differentiation. \n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.CmeModelWithSensitivity-Union{Tuple{PT}, Tuple{Any, Vector{var\"#s16\"} where var\"#s16\"<:Propensity, AbstractVector{T} where T}} where PT<:Propensity","page":"CME models","title":"NumCME.CmeModelWithSensitivity","text":"CmeModelWithSensitivity(stoich_matrix, propensities::Vector{PT}, parameters::AbstractVector) where {PT <: Propensity}\n\nConstruct a CME model with sensitivity information using a net stoichiometry matrix stoich_matrix and propensity functions propensities and parameters parameters. The partial derivatives of the propensity functions with respect to parameters are automatically derived using automatic differentiation.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_gradient_sparsity_patterns-Tuple{CmeModelWithSensitivity}","page":"CME models","title":"NumCME.get_gradient_sparsity_patterns","text":"get_gradient_sparsity_patterns(model::CmeModelWithSensitivity) -> SparseArrays.SparseMatrixCSC\n\n\nGet the sparse matrix representing dependency pattern of propensity functions of model parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_parameter_count-Tuple{CmeModelWithSensitivity}","page":"CME models","title":"NumCME.get_parameter_count","text":"get_parameter_count(model::CmeModelWithSensitivity) -> Any\n\n\nGet number of parrameters.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_parameter_count-Tuple{CmeModel}","page":"CME models","title":"NumCME.get_parameter_count","text":"get_parameter_count(model::CmeModel) -> Any\n\n\nGet number of parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_parameters-Tuple{CmeModelWithSensitivity}","page":"CME models","title":"NumCME.get_parameters","text":"get_parameters(model::CmeModelWithSensitivity) -> AbstractVector{T} where T\n\n\nGet parameter vectors of a Chemical Master Equation model instance.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_parameters-Tuple{CmeModel}","page":"CME models","title":"NumCME.get_parameters","text":"get_parameters(model::CmeModel) -> AbstractVector{T} where T\n\n\nGet the vector of model parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_propensities-Tuple{CmeModelWithSensitivity}","page":"CME models","title":"NumCME.get_propensities","text":"get_propensities(model::CmeModelWithSensitivity) -> Vector{var\"#s16\"} where var\"#s16\"<:Propensity\n\n\nGet the vector of propensities.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_propensities-Tuple{CmeModel}","page":"CME models","title":"NumCME.get_propensities","text":"get_propensities(model::CmeModel) -> Vector{var\"#s16\"} where var\"#s16\"<:Propensity\n\n\nGet vector of propensities.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_propensity_gradients-Tuple{CmeModelWithSensitivity}","page":"CME models","title":"NumCME.get_propensity_gradients","text":"get_propensity_gradients(model::CmeModelWithSensitivity) -> Vector{var\"#s16\"} where var\"#s16\"<:PropensityGradient\n\n\nGet the propensity gradients.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_reaction_count-Tuple{CmeModelWithSensitivity}","page":"CME models","title":"NumCME.get_reaction_count","text":"get_reaction_count(model::CmeModelWithSensitivity) -> Int64\n\n\nGet number of reactions in the model.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_reaction_count-Tuple{CmeModel}","page":"CME models","title":"NumCME.get_reaction_count","text":"get_reaction_count(model::CmeModel) -> Int64\n\n\nGet number of reactions.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_species_count-Tuple{CmeModelWithSensitivity}","page":"CME models","title":"NumCME.get_species_count","text":"get_species_count(model::CmeModelWithSensitivity) -> Int64\n\n\nGet the number of species (i.e., the length of the CME state vector).\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_species_count-Tuple{CmeModel}","page":"CME models","title":"NumCME.get_species_count","text":"get_species_count(model::CmeModel) -> Int64\n\n\nGet number of species.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_stoich_matrix-Tuple{CmeModelWithSensitivity}","page":"CME models","title":"NumCME.get_stoich_matrix","text":"get_stoich_matrix(model::CmeModelWithSensitivity) -> Matrix{IntT} where IntT<:Integer\n\n\nGet the net stoichiometry matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/models/#NumCME.get_stoich_matrix-Tuple{CmeModel}","page":"CME models","title":"NumCME.get_stoich_matrix","text":"get_stoich_matrix(model::CmeModel) -> Matrix{IntT} where IntT<:Integer\n\n\nGet net stoichiometry matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/space/#Managing-state-space","page":"Managing state space","title":"Managing state space","text":"","category":"section"},{"location":"api/space/","page":"Managing state space","title":"Managing state space","text":"Modules = [NumCME]\nPages = [\"statespace.jl\",\"sparsestatespace.jl\"]","category":"page"},{"location":"api/space/#NumCME.AbstractStateSpace","page":"Managing state space","title":"NumCME.AbstractStateSpace","text":"Abstract type for FSP state space. This is the supertype of all concrete FSP state space implementations.\n\n\n\n\n\n","category":"type"},{"location":"api/space/#NumCME.AbstractStateSpaceSparse","page":"Managing state space","title":"NumCME.AbstractStateSpaceSparse","text":"abstract type AbstractStateSpaceSparse{NS, NR, IntT<:Integer, SizeT<:Integer} <: AbstractStateSpace\n\n\n\n\n\n","category":"type"},{"location":"api/space/#NumCME.StateSpaceSparse","page":"Managing state space","title":"NumCME.StateSpaceSparse","text":"mutable struct StateSpaceSparse{NS, NR, IntT<:Integer, SizeT<:Integer} <: AbstractStateSpaceSparse{NS, NR, IntT<:Integer, SizeT<:Integer}\n\nBasic Sparse FSP State space.\n\nFields\n\nstoich_matrix\nStoichiometry matrix S = [s‚ÇÅ ... s‚Çò] of size N x M where N is the number of species, M the number of the reactions.\nsink_count\nNumber of sinks\nstates\nArray of CME states included in the subspace\nstate2idx\nDictionary of states, containing pairs (x=>i) for (i,x) in enumerate(states). The implementation must ensure that each state in states is a key in state2idx and conversely every key in state2idx exists in states.\nstate_connectivity\nList of state connectivity information. state_connectivity[i][k] = j if x·µ¢ = x‚±º + s‚Çñ, that is, states[i] = states[j] + stoich_mat[:, k]. If there is no existing state that can reach x·µ¢ via reaction k, the implementation must ensure that state_connectivity[i][k] = 0.\nsink_connectivity\nMatrix to store reaction events by which the included states transit to outside of the projected state space\n\nSee also\n\nexpand!,deleteat!\n\n\n\n\n\n","category":"type"},{"location":"api/space/#NumCME.StateSpaceSparse-Union{Tuple{SizeT}, Tuple{IntT}, Tuple{Matrix{IntT}, Vector{IntT}}} where {IntT<:Integer, SizeT<:Integer}","page":"Managing state space","title":"NumCME.StateSpaceSparse","text":"StateSpaceSparse(stoich_mat::Matrix{IntT}, init_state::Vector{IntT}; index_type::Type{<:Integer}=UInt32) \n\nConstruct a basic FSP state space with stoichiometry matrix stoich_mat and a single state init_state with their integer entries being stored in type IntT <: Integer. The optional keyword argument index_type allows for more customization on internal indexing representations.\n\nExamples\n\njldoctest julia> S = [[1,0] [-1,0] [0,1] [0,-1]] 2√ó4 Matrix{Int64}:  1  -1  0   0  0   0  1  -1  julia> x0 = [0,1] julia> StateSpaceSparse(S, states)`\n\n\n\n\n\n","category":"method"},{"location":"api/space/#NumCME.StateSpaceSparse-Union{Tuple{SizeT}, Tuple{IntT}, Tuple{Matrix{IntT}, Vector{T} where T}} where {IntT<:Integer, SizeT<:Integer}","page":"Managing state space","title":"NumCME.StateSpaceSparse","text":"mutable struct StateSpaceSparse{NS, NR, IntT<:Integer, SizeT<:Integer} <: AbstractStateSpaceSparse{NS, NR, IntT<:Integer, SizeT<:Integer}\n\nConstruct a basic FSP state space with stoichiometry matrix stoich_mat and initial list of states initstates with their integer entries being stored in type IntT <: Integer.\n\nExamples\n\njulia> S = [[1,0] [-1,0] [0,1] [0,-1]]\n2√ó4 Matrix{Int64}:\n 1  -1  0   0\n 0   0  1  -1\n julia> states = [[0,1], [10, 1], [0, 10]]\n 3-element Vector{Vector{Int64}}:\n [0, 1]\n [10, 1]\n [0, 10]\njulia> StateSpaceSparse(S, states)\n\n\n\n\n\n","category":"method"},{"location":"api/space/#Base.deleteat!-Union{Tuple{T}, Tuple{StateSpaceSparse, Vector{T}}} where T<:Integer","page":"Managing state space","title":"Base.deleteat!","text":"deleteat!(statespace::StateSpaceSparse, ids::Array{T<:Integer, 1})\n\n\nDelete states with indices ids from the state space.\n\n\n\n\n\n","category":"method"},{"location":"api/space/#NumCME.expand!-Union{Tuple{SizeT}, Tuple{IntT}, Tuple{NR}, Tuple{NS}, Tuple{StateSpaceSparse{NS, NR, IntT, SizeT}, Integer}} where {NS, NR, IntT<:Integer, SizeT<:Integer}","page":"Managing state space","title":"NumCME.expand!","text":"expand!(statespace::StateSpaceSparse{NS, NR, IntT<:Integer, SizeT<:Integer}, expansionlevel::Integer; onlyreactions)\n\n\nExpand the FSP state space to include all states that are reachable from the existing states in expansionlevel or fewer reaction events. State exploration direction is restricted to only reaction channels within onlyreactions if this argument is non-empty.\n\n\n\n\n\n","category":"method"},{"location":"api/space/#NumCME.get_sink_count-Tuple{StateSpaceSparse}","page":"Managing state space","title":"NumCME.get_sink_count","text":"get_sink_count(statespace::StateSpaceSparse) -> Integer\n\n\nReturn number of sinks. \n\n\n\n\n\n","category":"method"},{"location":"api/space/#NumCME.get_state_count-Tuple{StateSpaceSparse}","page":"Managing state space","title":"NumCME.get_state_count","text":"get_state_count(statespace::StateSpaceSparse) -> Int64\n\n\nReturn number of states.\n\n\n\n\n\n","category":"method"},{"location":"api/space/#NumCME.get_statedict-Tuple{StateSpaceSparse}","page":"Managing state space","title":"NumCME.get_statedict","text":"get_statedict(statespace::StateSpaceSparse) -> Dict{StaticArrays.MVector{NS, IntT}, SizeT} where {NS, IntT<:Integer, SizeT<:Integer}\n\n\nReturn state dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/space/#NumCME.get_states-Tuple{StateSpaceSparse}","page":"Managing state space","title":"NumCME.get_states","text":"get_states(statespace::StateSpaceSparse) -> Array{StaticArrays.MVector{NS, IntT}, 1} where {NS, IntT<:Integer}\n\n\nReturn list of states.\n\n\n\n\n\n","category":"method"},{"location":"api/space/#NumCME.get_stoich_matrix-Tuple{StateSpaceSparse}","page":"Managing state space","title":"NumCME.get_stoich_matrix","text":"get_stoich_matrix(space::StateSpaceSparse) -> Matrix{IntT} where IntT<:Integer\n\n\nReturn the stoichiometry matrix.\n\n\n\n\n\n","category":"method"},{"location":"examples/telegraph/#Telegraphic-gene-expression","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"","category":"section"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"In this example, we will compute the time-varying solutions of the Chemical Master Equation (CME) describing the telegraph gene expression network (see the picture below), starting from an initial condition where the gene is inactive and there are no gene product.","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"(Image: )","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"First let's make sure we can import the necessary Julia packages.","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"using NumCME\nusing Catalyst \nusing Sundials: CVODE_BDF\nusing StaticArrays: @MVector","category":"page"},{"location":"examples/telegraph/#Two-ways-to-input-a-stochastic-reaction-network-model","page":"Telegraphic gene expression","title":"Two ways to input a stochastic reaction network model","text":"","category":"section"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"NumCME supports inputing the stochastic reaction network model using Julia's standard library. If you decide to go this route, you need to first define the stoichiometry matrix, then the propensity functions, the parameter vector, and call CmeModel constructor to put these elements together into a single model object.","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"# Bursting gene model definition using basic Julia\nùïä = [[-1, 1, 0] [1, -1, 0] [0, 0, 1] [0, 0, -1]]\n\na1 = propensity() do x, p\n    p[1] * x[1]\nend\na2 = propensity() do x, p\n    p[2] * x[2]\nend\na3 = propensity() do x, p\n    p[3] * x[2]\nend\na4 = propensity() do x, p\n    p[4] * x[3]\nend\n\nkon = 0.05\nkoff = 0.1\nkr = 5.0\nŒ≥ = 0.5\nŒ∏ = [kon, koff, kr, Œ≥]\n\nmodel = CmeModel(ùïä, [a1, a2, a3, a4], Œ∏)","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"On the other hand, you can also define a model using Catalyst's DSL. The following code snippet defines a Catalyst.ReactionSystem object that represents the reactions and propensity functions of the telegraph model.","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"# Bursting model definition using Catalyst \n@parameters k‚ÇÄ‚ÇÅ k‚ÇÅ‚ÇÄ Œª Œ≥\nbursting_rn = @reaction_network begin \n    kon, Goff --> Gon\n    koff, Gon --> Goff \n    kr, Gon --> Gon + mRNA \n    Œ≥, mRNA --> ‚àÖ\nend k‚ÇÄ‚ÇÅ k‚ÇÅ‚ÇÄ Œª Œ≥","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"You can then convert it into NumCME.CmeModel object like so:","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"parameter_values = [koff => 0.05, kon => 0.1, kr => 5.0, Œ≥ => 0.5]\nmodel_from_catalyst = CmeModel(bursting_rn, parameter_values)","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"Let's solve the CME using both model objects.","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"x‚ÇÄ = [1, 0, 0]\np0 = FspVectorSparse([@MVector x‚ÇÄ], [1.0]) # Specify initial condition\ntspan = (0.0, 300.0)\nfspalgorithm = AdaptiveFspSparse(\n    ode_method=CVODE_BDF(linear_solver=:GMRES),\n    space_adapter=RStepAdapter(5, 10, true)\n)\nfspsol1 = solve(model, p0, tspan, fspalgorithm)\nfspsol2 = solve(model_from_catalyst, p0, tspan, fspalgorithm)","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"Do these two numerical solutions agree?","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"# Check that the two ways to code the model lead to the same numerical outputs \n@assert length(fspsol1) == length(fspsol2)\nfor i ‚àà 1:length(fspsol1)\n    @assert get_states(fspsol1[i].p) == get_states(fspsol2[i].p)\n    @assert get_values(fspsol1[i].p) == get_values(fspsol2[i].p)\nend","category":"page"},{"location":"examples/telegraph/#Which-method-is-faster?","page":"Telegraphic gene expression","title":"Which method is faster?","text":"","category":"section"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"We have verified that the two ways to specify the telegraph model lead to the same numerical output. However, does the use of DSL degrade performance? The answer is a resounding NO. Here are the benchmarking results on an Apple M1 13inch Macbook.","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"julia> using BenchmarkTools: @btime\njulia> @btime solve(model, p0, tspan, fspalgorithm);\n5.454 ms (122573 allocations: 4.50 MiB)","category":"page"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"julia> @btime solve(model_from_catalyst, p0, tspan, fspalgorithm);\n5.418 ms (122573 allocations: 4.50 MiB)","category":"page"},{"location":"examples/telegraph/#Remarks","page":"Telegraphic gene expression","title":"Remarks","text":"","category":"section"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"Specifying three species does not increase the number of states included in the FSP compared to formulating it as a two-species system (with gene ‚àà {ON, OFF} and RNA ‚àà {0,1,2,...} ). This is because only states that satisfy Goff + Gon == 1 are reachable from the initial condition and NumCME's state space management, which is based on a reachability analysis of the CME state space, respects this constraint automatically. This is a feature of the \"N-step reachability\" state space exploration shceme introduced in the very first FSP paper by Munsky and Khammash [1].\nThus, the estimate that the number of states increases as O(n^d), while a useful heuristics, can be pessimistic for reaction networks with mass conservation.","category":"page"},{"location":"examples/telegraph/#References","page":"Telegraphic gene expression","title":"References","text":"","category":"section"},{"location":"examples/telegraph/","page":"Telegraphic gene expression","title":"Telegraphic gene expression","text":"[1]: B. Munsky and M. Khammash, ‚ÄúThe finite state projection algorithm for the solution of the chemical master equation,‚Äù J. Chem. Phys., vol. 124, no. 4, p. 044104, Jan. 2006, doi: 10.1063/1.2145882.‚óä","category":"page"},{"location":"examples/hog1p/#MAPK-activated-transcription-in-yeast","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"","category":"section"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"In this example, we solve a four-state, two-compartment, MAPK-activated gene expression model taken from a published work by Munsky et al.[1]. The reaction system is","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"(Image: )","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"Here, G_0 G_1 G_2 G_3 represent four activation states of the gene of interest. RNA_nuc is the gene's transcriptional product in the nucleus and RNA_cyt is the gene's transcript that has been relocated to the cytoplasm. The deactivation rate k_10(t) = k_10^textconst is a constant when there is no Hog1p signal. When there is signal, the rate is time-dependent and is given by ","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"k_10(t) = maxleft(00 k_10^textconst - a operatornameHog1p(t)right)","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"where ","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"operatornameHog1p(t)\n=\nA_hog\nleft(\n    fracu(t)1 + u(t)M_hog\nright)^eta","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"with u(t) = (1 - e^-r_1t)e^-r_2t.","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"First, let's import NumCME and other useful packages","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"using NumCME \nusing Catalyst\nusing StaticArrays: @MVector\nusing Sundials: CVODE_BDF","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"Now, we will code up the time-varying Hog1p signal. Here, we use the parameters provided by the paper.","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"const r1 = 6.1e-3\nconst r2 = 6.9e-3\nconst Œ∑ = 5.9\nconst Ahog = 9.3e9\nconst Mhog = 2.2e-2\nfunction Hog1p(t)\n    u = (1.0 - exp(-r1 * t)) * exp(-r2 * t)\n    signal = Ahog * (u / (1.0 + u / Mhog))^Œ∑\n    return signal \nend","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"We use Catalyst.jl's beautiful domain-specific language (DSL) to define the reactions and rates of the model. You can see that the code is almost self-explanatory.","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"@parameters k01, k10const, a, k12, k21, k23, k32, Œª0, Œª1, Œª2, Œª3, ktrans, Œ≥nuc, Œ≥cyt\nrn = @reaction_network begin \n    k01, G0 --> G1\n    max(0, k10const - a*Hog1p(t)), G1 --> G0 \n    k12, G1 --> G2 \n    k21, G2 --> G1 \n    k23, G2 --> G3\n    k32, G3 --> G2\n    Œª0, G0 --> G0 + RNAnuc \n    Œª1, G1 --> G1 + RNAnuc\n    Œª2, G2 --> G2 + RNAnuc \n    Œª3, G3 --> G3 + RNAnuc \n    Œ≥nuc, RNAnuc --> ‚àÖ\n    ktrans, RNAnuc --> RNAcyt \n    Œ≥cyt, RNAcyt --> ‚àÖ\nend k01 k10const a k12 k21 k23 k32 Œª0 Œª1 Œª2 Œª3 Œ≥nuc ktrans Œ≥cyt","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"Let's define a dictionary for the parameter values. We use parameters provided by the paper, which werre fitted to the STL1 gene transcription data.","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"param_values = Dict([\nk01=> 2.6e-3,\nk10const=> 1.9e01,\na=> 0.0,\nk12=> 7.63e-3,\nk21=> 1.2e-2,\nk23=> 4e-3,\nk32=> 3.1e-3,\nŒª0=> 5.9e-4,\nŒª1=> 1.7e-1,\nŒª2=> 1.0,\nŒª3=> 3e-2,\nktrans=> 2.6e-1,\nŒ≥nuc=> 2.2e-6,\nŒ≥cyt=> 8.3e-3\n])","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"Note that we are setting the value for parameter a to 0.0 since we want to simulate the long time behavior of the cell prior to MAPK activation. This is acomplished with the following code","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"# Simulate long-time behavior before MAPK signal \nmodel = CmeModel(rn, collect(param_values))\np0 = FspVectorSparse([@MVector [1,0,0,0,0,0]], [1.0])\nfsp = AdaptiveFspSparse(\n    ode_method = CVODE_BDF(linear_solver=:GMRES),\n    space_adapter = RStepAdapter(10,20,true)\n)\nsol = solve(\n    model, \n    p0,\n    (0.0, 8*3600.0),\n    fsp;\n    saveat = [8*3600.0],\n    fsptol = 1.0e-6,\n    odeatol = 1.0e-14,\n    odertol = 1.0e-6,\n    verbose=true\n);\npend = sol[end].p","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"The last line extracts the probability distribution at the final solution time of the FSP run. We are using a sparse representation so pend's type would be FspVectorSparse.","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"Now, we are ready to simulate the transient behavior of the cell under osmotic shock. With Hog1p entering the cell, the gene deactivation rate will be modulated by a non-trivial amount. So we adjust the value of parameter a using the value provided in the paper, then make a new CmeModel object with the updated parameter values dictionary.","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"param_values[a] = 3.2e04\nmodel = CmeModel(rn, collect(param_values))","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"Now, let's solve the CME again with the addition of Hog1p signal. We are interested in the solution up to one hour (3600 second) after signal addition, and save intermediate solutions every minute.","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"sol = solve(\n    model, \n    pend,\n    (0.0, 3600.0), \n    fsp;\n    saveat = [t for t in 0.0:60.0:3600.0],\n    fsptol = 1.0e-4,\n    odeatol = 1.0e-14,\n    odertol = 1.0e-6,\n    verbose=true\n);","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"Now, we are ready to make some animation.","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"using Plots \n\nanim = @animate for i ‚àà 1:length(sol)\n    pfull = sol[i].p \n    pnuc = sum(pfull, [1,2,3,4,6]) |> Array \n    pcyt = sum(pfull, [1,2,3,4,5]) |> Array \n    rnaplot = plot()\n    plot!(rnaplot, 0:length(pnuc)-1, pnuc, color=:blue, label=\"Nuclear mRNA\")\n    plot!(rnaplot, 0:length(pcyt)-1, pcyt, color=:red, label=\"Cytoplasmic mRNA\")\n    ylims!(rnaplot, (0.0, 1.0))\n    xlims!(rnaplot, (0, 20))\n    xlabel!(rnaplot, \"Molecule count\")\n    ylabel!(rnaplot,\"Probability\")\n    title!(rnaplot, \"t = $(sol.t[i]/60.0) minute\")\nend\ngif(anim, \"hog1p.gif\", fps = 10)","category":"page"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"(Image: )","category":"page"},{"location":"examples/hog1p/#References","page":"MAPK-activated transcription in yeast","title":"References","text":"","category":"section"},{"location":"examples/hog1p/","page":"MAPK-activated transcription in yeast","title":"MAPK-activated transcription in yeast","text":"[1]: B. Munsky, G. Li, Z. R. Fox, D. P. Shepherd, and G. Neuert, ‚ÄúDistribution shapes govern the discovery of predictive models for gene regulation,‚Äù PNAS, vol. 115, no. 29, pp. 7533‚Äì7538, Jul. 2018, doi: 10.1073/pnas.1804060115.","category":"page"},{"location":"api/vectors/#Representing-the-CME-solution","page":"Representing the CME solution","title":"Representing the CME solution","text":"","category":"section"},{"location":"api/vectors/","page":"Representing the CME solution","title":"Representing the CME solution","text":"Modules = [NumCME]\nOrder = [:type, :function]\nPages = [\"fspvector.jl\"]","category":"page"},{"location":"api/vectors/#Core.Array-Union{Tuple{FspVectorSparse{NS, IntT, RealT}}, Tuple{RealT}, Tuple{IntT}, Tuple{NS}} where {NS, IntT<:Integer, RealT<:AbstractFloat}","page":"Representing the CME solution","title":"Core.Array","text":"Array(p::FspVectorSparse)\n\nConstruct a new dense N-dimensional array from the FSP vector.\n\n\n\n\n\n","category":"method"},{"location":"api/vectors/#NumCME.FspVectorSparse","page":"Representing the CME solution","title":"NumCME.FspVectorSparse","text":"FspVectorSparse{NS, IntT<:Integer, RealT<:AbstractFloat} <: AbstractFspVector\n\nSparse multi-indexed vector (i.e., sparse \"tensor\") with entries of type RealT and multi-indices of type IntT for storing CME solution and sensitivity vectors output by the Finite State Projection.   \n\n\n\n\n\n","category":"type"},{"location":"api/vectors/#NumCME.FspVectorSparse-Union{Tuple{RealT}, Tuple{IntT}, Tuple{NS}, Tuple{Array{StaticArrays.MVector{NS, IntT}, 1}, Vector{RealT}}} where {NS, IntT<:Integer, RealT<:AbstractFloat}","page":"Representing the CME solution","title":"NumCME.FspVectorSparse","text":"FspVectorSparse(states::Vector{MVector{NS, IntT}}, values::Vector{RealT})\n\nConstruct a sparse representation of a FSP-truncated probability distribution with support states and proability values values.\n\n\n\n\n\n","category":"method"},{"location":"api/vectors/#NumCME.FspVectorSparse-Union{Tuple{RealT}, Tuple{VecT}, Tuple{IntT}, Tuple{NR}, Tuple{NS}, Tuple{AbstractStateSpaceSparse{NS, NR, IntT, SizeT} where SizeT<:Integer, Array{Pair{VecT, RealT}, 1}}} where {NS, NR, IntT<:Integer, VecT<:(AbstractVector{T} where T), RealT<:AbstractFloat}","page":"Representing the CME solution","title":"NumCME.FspVectorSparse","text":"FspVectorSparse(statespace::AbstractStateSpaceSparse{NS, NR, IntT}, statevalpairs::Vector{Pair{VecT, RealT}})\n\nConstruct a sparse representation of a FSP-truncated probability distribution on the state space statespace and proability values values.\n\n\n\n\n\n","category":"method"},{"location":"api/vectors/#Base.sum-Union{Tuple{RealT}, Tuple{IntT}, Tuple{NS}, Tuple{FspVectorSparse{NS, IntT, RealT}, AbstractVector{var\"#s32\"} where var\"#s32\"<:Integer}} where {NS, IntT<:Integer, RealT<:AbstractFloat}","page":"Representing the CME solution","title":"Base.sum","text":"sum(p::FspVectorSparse, dims)\n\nReduce the FSP vector p by summing over species specified in dims and return a new FSP vector over a reduced-dimension state space.\n\n\n\n\n\n","category":"method"},{"location":"api/propensities/#Propensity-functions","page":"Propensity functions","title":"Propensity functions","text":"","category":"section"},{"location":"api/propensities/","page":"Propensity functions","title":"Propensity functions","text":"Propensity ","category":"page"},{"location":"api/propensities/#NumCME.Propensity","page":"Propensity functions","title":"NumCME.Propensity","text":"Base type for all propensities.\n\n\n\n\n\n","category":"type"},{"location":"api/propensities/","page":"Propensity functions","title":"Propensity functions","text":"StandardTimeInvariantPropensity","category":"page"},{"location":"api/propensities/#NumCME.StandardTimeInvariantPropensity","page":"Propensity functions","title":"NumCME.StandardTimeInvariantPropensity","text":"StandardTimeInvariantPropensity\n\nPropensity function for a reaction with rate not dependent on time. \n\nExamples\n\nA standard time-invariant propensity can be created by wrapping around a Julia function. The function must accept two inputs x, p where x is the CME state vector and p is the vector of parameters.\n\njulia> f(x, p) = p[1]*x[1]\nf (generic function with 1 method)\njulia> Œ± = StandardTimeInvariantPropensity(f)\nStandardTimeInvariantPropensity(f)\njulia> Œ±([1,2], [0.1,0.2])\n0.1\n\nOne can also input f into the propensity() function. Provided that f is a function of two arguments with the CME state argument followed by the parameter argument, propensity() will output a standard time-invariant propensity. Continuing the example above, \n\njulia> Œ≤ = propensity(f)\nStandardTimeInvariantPropensity(f)\njulia> Œ≤([1,2], [0.1,0.2]) == Œ±([1,2], [0.1,0.2])\ntrue \n\nOne can also take advantage of Julia's do block to make the code more concise.\n\njulia> Œ≥ = propensity() do x,p\n        x[1]*p[1]\n    end \njulia> Œ≥([1,2], [0.1,0.2])\n0.1\n\n\n\n\n\n","category":"type"},{"location":"api/propensities/","page":"Propensity functions","title":"Propensity functions","text":"SeparableTimeVaryingPropensity","category":"page"},{"location":"api/propensities/#NumCME.SeparableTimeVaryingPropensity","page":"Propensity functions","title":"NumCME.SeparableTimeVaryingPropensity","text":"SeparableTimeVaryingPropensity\n\nReaction propensity with a time-varying rate that can be factorized into a function that depends only on the time variable (and parameters) and another function that does not depend on time. Subsequent types that build upon this type (such as FspMatrixSparse) takes advantage of time-space separability to avoid repeating expensive computations.\n\nExamples\n\nA separable time-varying propensity can be created by specifying two Julia functions. The first function represents the time-varying factor and accepts two input arguments t (for time) and p (for parameters), the second function represents the time-invariant factor and accepts two input arguments x (for CME state) and p (for parameters).\n\njulia> c(t,p) = (1.0+cos(œÄ*t/p[2]))\nc (generic function with 1 method)\njulia> f(x, p) = p[1]*x[1]\nf (generic function with 1 method)\njulia> Œ± = SeparableTimeVaryingPropensity(c,f)\nSeparableTimeVaryingPropensity(c,f)\njulia> Œ±(20.0,[1,2], [0.1,0.2])\n0.2\n\nOne can also use a method of the propensity() function to create a SeparableTimeVaryingPropensity instance. Provided that f is a function of two arguments with the CME state argument followed by the parameter argument, propensity(f,c) (note that the time-varying factor comes after the time-invariant factor) will output a standard time-invariant propensity. Continuing the example above, \n\njulia> Œ≤ = propensity(f,c)\nSeparableTimeVaryingPropensity(f, c)\njulia> Œ≤(20.0, [1,2], [0.1,0.2]) == Œ±(20.0, [1,2], [0.1,0.2])\ntrue \n\nOne can also take advantage of Julia's do block to make the code more concise.\n\njulia> Œ≥ = propensity((1.0+cos(œÄ*t/p[2]))) do x,p\n        x[1]*p[1]\n    end \njulia> SeparableTimeVaryingPropensity(var\"#19#21\"(), var\"#18#20\"())\njulia> Œ≥(20.0, [1,2], [0.1,0.2])\n0.2\n\n\n\n\n\n","category":"type"},{"location":"api/propensities/","page":"Propensity functions","title":"Propensity functions","text":"JointTimeVaryingPropensity","category":"page"},{"location":"api/propensities/#NumCME.JointTimeVaryingPropensity","page":"Propensity functions","title":"NumCME.JointTimeVaryingPropensity","text":"JointTimeVaryingPropensity\n\nReaction propensity with a time-varying rate. For speed, we recommend using SeparableTimeVaryingPropensity if the propensity function has a separable structure.\n\nExamples\n\nA time-varying propensity can be created by wrapping a function with three input arguments, t (for time) x (for CME state) and p (for parameters).\n\njulia> f(t, x, p) = (1.0+cos(œÄ*t/p[2]))*p[1]*x[1]\nf (generic function with 1 method)\njulia> Œ± = JointTimeVaryingPropensity(c,f)\nJointTimeVaryingPropensity(c,f)\njulia> Œ±(20.0,[1,2], [0.1,0.2])\n0.2\n\nOne can also use a method of the propensity() function to create a JointTimeVaryingPropensity instance. Provided that f is a function of three arguments with time as the first argument, the CME state as the second argument followed by the parameter argument.\n\njulia> Œ≤ = propensity(f)\njulia> Œ≤(20.0, [1,2], [0.1,0.2]) == Œ±(20.0, [1,2], [0.1,0.2])\ntrue \n\n\n\n\n\n","category":"type"},{"location":"api/cmesenssolve/#Forward-sensitivity-analysis","page":"Forward sensitivity analysis","title":"Forward sensitivity analysis","text":"","category":"section"},{"location":"api/cmesenssolve/#Forward-Sensitivity-FSP-variant-specification","page":"Forward sensitivity analysis","title":"Forward Sensitivity FSP variant specification","text":"","category":"section"},{"location":"api/cmesenssolve/","page":"Forward sensitivity analysis","title":"Forward sensitivity analysis","text":"AdaptiveForwardSensFspSparse","category":"page"},{"location":"api/cmesenssolve/#NumCME.AdaptiveForwardSensFspSparse","page":"Forward sensitivity analysis","title":"NumCME.AdaptiveForwardSensFspSparse","text":"struct AdaptiveForwardSensFspSparse <: ForwardSensCmeAlgorithm\n\nType to store algorithmic options for solving a Foward Sensitivity CME problem.\n\nFields\n\nspace_adapter\nMethod to adapt state space when the current solution error exceeds tolerance.\n\node_method\nAn ODE solver from DifferentialEquations.jl to integrate the FSP-truncated problem.\n\nSee also\n\nForwardSensRStepAdapter\n\n\n\n\n\n","category":"type"},{"location":"api/cmesenssolve/#State-space-adaptation-policy","page":"Forward sensitivity analysis","title":"State space adaptation policy","text":"","category":"section"},{"location":"api/cmesenssolve/","page":"Forward sensitivity analysis","title":"Forward sensitivity analysis","text":"Modules = [NumCME]\nPages = [\n    \"forwardsenscme/sparse/fsspaceadapterssparse.jl\"\n]","category":"page"},{"location":"api/cmesenssolve/#NumCME.ForwardSensRStepAdapter","page":"Forward sensitivity analysis","title":"NumCME.ForwardSensRStepAdapter","text":"Simple adapter based on reachability. Whenever the current FSP solution error is found to exceed the acceptable tolerance, the adapter will expand the state space by exploring all states that could be reached from the current state space within a set number of reaction events.\n\nThis adapter only works with StateSpaceSparse.\n\n\n\n\n\n","category":"type"},{"location":"api/cmesenssolve/#NumCME.adapt!-Union{Tuple{RealT}, Tuple{StateSpaceSparse, ForwardSensRStepAdapter, Vector{RealT}, Array{Vector{RealT}, 1}, Vector{RealT}, Array{Vector{RealT}, 1}, RealT, RealT, RealT}} where RealT<:AbstractFloat","page":"Forward sensitivity analysis","title":"NumCME.adapt!","text":"adapt!(statespace::StateSpaceSparse, adapter::RStepAdapter, p::Vector{RealT}, sinks::Vector{RealT}, t::RealT, fsptol::RealT; integrator::Union{DEIntegrator, Nothing}=nothing) where {RealT <: AbstractFloat}\n\nAdapt the state space, probability vector and sensitivity vectors based on current error recorded in the sinks vector.\n\n\n\n\n\n","category":"method"},{"location":"api/cmesenssolve/#NumCME.init!-Union{Tuple{RealT}, Tuple{StateSpaceSparse, ForwardSensRStepAdapter, Vector{RealT}, Array{Vector{RealT}, 1}, AbstractFloat, AbstractFloat}} where RealT<:AbstractFloat","page":"Forward sensitivity analysis","title":"NumCME.init!","text":"init!(statespace::StateSpaceSparse, adapter::RStepAdapter, p::Vector{RealT}, S::Vector{Vector{RealT}}, t::RealT, fsptol::RealT) where {RealT <: AbstractFloat}\n\nInitialize the state space, solution vector and sensitivity indices for FSP integration.\n\n\n\n\n\n","category":"method"},{"location":"api/cmesenssolve/#Forward-sensitivity-FSP-output-format","page":"Forward sensitivity analysis","title":"Forward sensitivity FSP output format","text":"","category":"section"},{"location":"api/cmesenssolve/","page":"Forward sensitivity analysis","title":"Forward sensitivity analysis","text":"Modules = [NumCME]\nPages = [\n    \"forwardsenscme/sparse/sensoutputsparse.jl\"\n]","category":"page"},{"location":"api/cmesenssolve/#NumCME.ForwardSensFspOutputSliceSparse","page":"Forward sensitivity analysis","title":"NumCME.ForwardSensFspOutputSliceSparse","text":"ForwardSensFspOutputSliceSparse\n\nStruct to store the Forward Sensitivity FSP solution at a single time. Fields: t, p, S, sinks, dsinks.\n\n\n\n\n\n","category":"type"},{"location":"api/cmesenssolve/#NumCME.ForwardSensFspOutputSparse","page":"Forward sensitivity analysis","title":"NumCME.ForwardSensFspOutputSparse","text":"ForwardSensFspOutputSparse{NS,IntT<:Integer,RealT<:AbstractFloat}\n\nStruct to store Forward Sensitivity Finite State Projection outputs based on the sparse representation of the FSP solution.\n\nFields\n\nt: Array of solution output times.\np: Array of FspVectorSparse instances. p[i] is the CME solution at time t[i].\n'S': Array of arrays of FspVectorSparse instances. S[j][i] is the j-th partial derivative of p[i]. \nsinks: Probability mass accumulated at the sink states over time. sinks[i] is the vector of sink state probabilities at time t[i].\ndsinks: Partial derivatives of sink probabilties. dsinks[j][i] is the j-th partial derivative of sinks[i].\n\nUsage\n\nIf sol is of type FspOutputSparse, sol[i] will return a slice, of type FspOutputSliceSparse of the solution set at the i-th index. \n\nSee also\n\nForwardSensFspOutputSliceSparse.\n\n\n\n\n\n","category":"type"},{"location":"api/cmesenssolve/#solve()-method","page":"Forward sensitivity analysis","title":"solve() method","text":"","category":"section"},{"location":"api/cmesenssolve/","page":"Forward sensitivity analysis","title":"Forward sensitivity analysis","text":"Modules = [NumCME]\nPages = [\"forwardsenscme.jl\",                \n        \"forwardsenscme/sparse/forwardsenscmesparse.jl\"\n        ]\nsolve ","category":"page"},{"location":"api/cmesenssolve/#NumCME.ForwardSensFspInitialConditionSparse","page":"Forward sensitivity analysis","title":"NumCME.ForwardSensFspInitialConditionSparse","text":"struct ForwardSensFspInitialConditionSparse{NS, IntT<:Integer, RealT<:AbstractFloat}\n\nInitial condition for Foward Sensitivity FSP in sparse format. \n\nFields\n\nstates\nList of states with nonzero initial probabilities.\n\np\nList of nonzero probabilities, with p[i] being the probability of state states[i].\n\nS\nList of partial derivatives, with S[j][i] being the j-th partial derivative of p[i].\n\n\n\n\n\n","category":"type"},{"location":"api/cmesenssolve/#CommonSolve.solve-Union{Tuple{RealT}, Tuple{IntT}, Tuple{NS}, Tuple{CmeModelWithSensitivity, ForwardSensFspInitialConditionSparse{NS, IntT, RealT}, Tuple{AbstractFloat, AbstractFloat}, AdaptiveForwardSensFspSparse}} where {NS, IntT<:Integer, RealT<:AbstractFloat}","page":"Forward sensitivity analysis","title":"CommonSolve.solve","text":"solve(model::CmeModelWithSensitivity, initial_condition::ForwardSensFspInitialConditionSparse{NS, IntT<:Integer, RealT<:AbstractFloat}, tspan::Tuple{AbstractFloat, AbstractFloat}, sensfspalgorithm::AdaptiveForwardSensFspSparse; saveat, fsptol, odeatol, odertol, verbose) -> Any\n\n\nFoward sensitivity Finite State Projection to compute the time-dependent probability distributions of a stochastic reaction network along with their partial derivatives with respect to model parameters.\n\nArguments\n\nmodel: Stochastic reaction network model with propensity sensitivities.\ninitial_condition: Initial condition.\ntspan: Time span. \nsensfspalgorithm: Forward Sesitivity FSP method, a combination of space adaptation strategy and the ODE method to integrate the FSP-truncated problem.\nsaveat: timepoints to save the intermediate solutions. If left empty, all timesteps computed by the ODE solver is saved.\nfsptol: FSP error tolerance. The solver dynamically adapts the projection space so that the sum of probability mass in the truncated solution is above 1.0 - fsptol. Default: 1.0E-6.\nodeatol: Absolute tolerance for the ODE solver. Default: 1.0E-10.\nodertol: Relative tolerance for the ODE solver. Default: 1.0E-4.\nverbose: Whether to print status when adapting state space. Default: false.\n\nReturns\n\nA ForwardSensFspOutputSparse instance.\n\nSee also\n\nFspVectorSparse, ForwardSensFspOutputSparse, AdaptiveForwardSensFspSparse.\n\n\n\n\n\n","category":"method"},{"location":"api/cmesenssolve/#NumCME.forwardsens_initial_condition-Union{Tuple{RealT}, Tuple{IntT}, Tuple{Vector{var\"#s73\"} where var\"#s73\"<:AbstractVector{IntT}, Vector{RealT}, Array{Vector{RealT}, 1}}} where {IntT<:Integer, RealT<:AbstractFloat}","page":"Forward sensitivity analysis","title":"NumCME.forwardsens_initial_condition","text":"forwardsens_initial_condition(states::Array{var\"#s73\", 1} where var\"#s73\"<:AbstractArray{IntT<:Integer, 1}, probabilities::Array{RealT<:AbstractFloat, 1}, sensitivity::Array{Array{RealT<:AbstractFloat, 1}, 1}) -> ForwardSensFspInitialConditionSparse\n\n\nReturn a ForwardSensFspInitialConditionSparse instance from a list of initial states states, initial probabilities probabilities and initial sensitivities sensitivity.   \n\n\n\n\n\n","category":"method"},{"location":"#NumCME.jl","page":"Home","title":"NumCME.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An extensible toolkit for direct numerical solution of the Chemical Master Equation based on the Finite State Projection and related algorithms.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims to offer dynamic, fast, and customizable methods for direct numerical integration of the Chemical Master Equation (CME) in Julia. Currently, it has:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Transient solution of the CME for time-homogeneous reaction rates/propensities as well as time-varying reaction rates/propensities using Finite State Projection and related variants.\nDynamic state spaces: The truncated state space is adapted on-the-fly to remove redundant states with low probabilities and add more states to ensure the truncation error is within user-specified tolerance.\nCustomizability: Users can choose how the dynamic state space is managed (by specifying parameters for existing SpaceAdapter subtypes or write their own SpaceAdapter) and how the reduced ODEs are solved (by choosing one among the multitude options offered by DifferentialEquations.jl). Advanced users can write their own dynamic state space management policy by subtyping SpaceAdapter.\nSensitivity analysis: Compute partial derivatives of the FSP solution with respect to model parameters. Users do not need to write analytic expressions of the propensity's partial derivatives. Instead, the package applies existing tools from ModelingToolkit.jl and ForwardDiff.jl to generate those derivatives automatically.\nInterface to Catalyst.jl package to accept reaction systems defined using Catalyst DSL.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed using Julia's package management. For the last stable version from the General Registry,","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"NumCME\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the latest commit on this repository, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"https://github.com/voduchuy/NumCME.jl\")","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Thanks to Kaan √ñcal for the helpful conversation during UQ-Bio 2021 about Julia and Catalyst.","category":"page"},{"location":"api/propensity_gradients/#Gradients-of-propensity-functions","page":"Gradients of propensity functions","title":"Gradients of propensity functions","text":"","category":"section"},{"location":"api/propensity_gradients/","page":"Gradients of propensity functions","title":"Gradients of propensity functions","text":"Modules = [NumCME]\nPages = [\"propensitygrad.jl\"]","category":"page"},{"location":"api/propensity_gradients/#NumCME.JointTimeVaryingPropensityGradient","page":"Gradients of propensity functions","title":"NumCME.JointTimeVaryingPropensityGradient","text":"Store the partial derivatives of a JointTimeVaryingPropensity instance. \n\nFields\n\npardiffs: Vector of callables, whose length is the number of model parameters. Each of these callables has syntax pardiffs[i](t,x,p)::Real where t is time, x is the state vector and p the parameter vector.\n\n\n\n\n\n","category":"type"},{"location":"api/propensity_gradients/#NumCME.PropensityGradient","page":"Gradients of propensity functions","title":"NumCME.PropensityGradient","text":"Base type for all propensity gradients.\n\n\n\n\n\n","category":"type"},{"location":"api/propensity_gradients/#NumCME.SeparableTimeVaryingPropensityGradient","page":"Gradients of propensity functions","title":"NumCME.SeparableTimeVaryingPropensityGradient","text":"Store the partial derivatives of a SeparableTimeVaryingPropensity instance. \n\nFields\n\ntfactor: Callable in the form tfactor(t,p) where t is time, p is parameter vector.\nstatefactor: Callable in the form statefactor(x,p) where x is CME state, p the parameter vector.\ntfactor_pardiffs: Vector of callables. Each of these callables has syntax tfactor_pardiffs[i](t,p)::Real where t is time variable and p the parameter vector.\nstatefactor_pardiffs: Vector of callables, whose length is the number of model parameters. Each of these callables has syntax statefactor_pardiffs[i](x,p)::Real where x is the state vector and p the parameter vector.\n\n\n\n\n\n","category":"type"},{"location":"api/propensity_gradients/#NumCME.StandardTimeInvariantPropensityGradient","page":"Gradients of propensity functions","title":"NumCME.StandardTimeInvariantPropensityGradient","text":"Store the partial derivatives of a StandardTimeInvariantPropensity instance. \n\nFields\n\npardiffs: Vector of callables, whose length is the number of model parameters. Each of these callables has syntax pardiffs[i](x,p)::Real where x is the state vector and p the parameter vector.\n\n\n\n\n\n","category":"type"},{"location":"api/cmesolve/#Transient-solution-of-the-CME","page":"Transient solution of the CME","title":"Transient solution of the CME","text":"","category":"section"},{"location":"api/cmesolve/#FSP-variant-specification","page":"Transient solution of the CME","title":"FSP variant specification","text":"","category":"section"},{"location":"api/cmesolve/","page":"Transient solution of the CME","title":"Transient solution of the CME","text":"AdaptiveFspSparse","category":"page"},{"location":"api/cmesolve/#NumCME.AdaptiveFspSparse","page":"Transient solution of the CME","title":"NumCME.AdaptiveFspSparse","text":"mutable struct AdaptiveFspSparse <: TransientCmeAlgorithm\n\nStruct to store adaptive Finite State Projection algorithmic options. This type is intended to work with solve() methods that output CME solutions as sparse vectors of type FspVectorSparse. \n\nFields\n\node_method\n\nInstance of an ODE algorithm from the DifferentialEquations.jl package.\n\nspace_adapter\n\nMethod to adapt the FSP state space when truncation error exceeds user-specified tolerance.\n\nSee also\n\nRStepAdapter, FspVectorSparse, CmeModel\n\n\n\n\n\n","category":"type"},{"location":"api/cmesolve/#State-space-adaptation-policies","page":"Transient solution of the CME","title":"State space adaptation policies","text":"","category":"section"},{"location":"api/cmesolve/","page":"Transient solution of the CME","title":"Transient solution of the CME","text":"Modules = [NumCME]\nPages = [\"spaceadapters.jl\",\n        \"rstepadapters.jl\"\n        ]","category":"page"},{"location":"api/cmesolve/#NumCME.RStepAdapter","page":"Transient solution of the CME","title":"NumCME.RStepAdapter","text":"struct RStepAdapter <: AbstractSpaceAdapterSparse\n\nSimple adapter based on reachability. Whenever the current FSP solution error is found to exceed the acceptable tolerance, the adapter will expand the state space by exploring all states that could be reached from the current state space within a set number of reaction events.\n\nThis adapter only works with StateSpaceSparse.\n\n\n\n\n\n","category":"type"},{"location":"api/cmesolve/#NumCME.SelectiveRStepAdapter","page":"Transient solution of the CME","title":"NumCME.SelectiveRStepAdapter","text":"struct SelectiveRStepAdapter <: AbstractSpaceAdapterSparse\n\nAdapter based on reachability. This adapter only explore new states through reaction channels with positive derivatives. \n\nThis adapter only works with StateSpaceSparse.\n\n\n\n\n\n","category":"type"},{"location":"api/cmesolve/#NumCME.adapt!-Tuple{StateSpaceSparse, SelectiveRStepAdapter, Vector{var\"#s68\"} where var\"#s68\"<:AbstractFloat, Vector{var\"#s67\"} where var\"#s67\"<:AbstractFloat, AbstractFloat, AbstractFloat, AbstractFloat}","page":"Transient solution of the CME","title":"NumCME.adapt!","text":"adapt!(statespace::StateSpaceSparse, adapter::SelectiveRStepAdapter, p::Vector{var\"#s68\"} where var\"#s68\"<:AbstractFloat, sinks::Vector{var\"#s67\"} where var\"#s67\"<:AbstractFloat, t::AbstractFloat, tend::AbstractFloat, fsptol::AbstractFloat; integrator)\n\n\nAdapt the state space and probability vector based on current error recorded in the sinks vector.\n\n\n\n\n\n","category":"method"},{"location":"api/cmesolve/#NumCME.adapt!-Union{Tuple{RealT}, Tuple{StateSpaceSparse, RStepAdapter, Vector{RealT}, Vector{RealT}, RealT, RealT, RealT}} where RealT<:AbstractFloat","page":"Transient solution of the CME","title":"NumCME.adapt!","text":"adapt!(statespace::StateSpaceSparse, adapter::RStepAdapter, p::Array{RealT<:AbstractFloat, 1}, sinks::Array{RealT<:AbstractFloat, 1}, t::AbstractFloat, tend::AbstractFloat, fsptol::AbstractFloat; integrator)\n\n\nAdapt the state space and probability vector based on current error recorded in the sinks vector.\n\n\n\n\n\n","category":"method"},{"location":"api/cmesolve/#NumCME.init!-Tuple{StateSpaceSparse, RStepAdapter, Vector{var\"#s74\"} where var\"#s74\"<:AbstractFloat, AbstractFloat, AbstractFloat}","page":"Transient solution of the CME","title":"NumCME.init!","text":"init!(statespace::StateSpaceSparse, adapter::RStepAdapter, p::Vector{var\"#s74\"} where var\"#s74\"<:AbstractFloat, t::AbstractFloat, fsptol::AbstractFloat)\n\n\nMake the state space and solution vector ready for FSP integration.\n\n\n\n\n\n","category":"method"},{"location":"api/cmesolve/#NumCME.init!-Union{Tuple{RealT}, Tuple{StateSpaceSparse, SelectiveRStepAdapter, Vector{RealT}, RealT, RealT}} where RealT<:AbstractFloat","page":"Transient solution of the CME","title":"NumCME.init!","text":"init!(statespace::StateSpaceSparse, adapter::SelectiveRStepAdapter, p::Array{RealT<:AbstractFloat, 1}, t::AbstractFloat, fsptol::AbstractFloat)\n\n\ninit!(statespace::StateSpaceSparse, adapter::SelectiveRStepAdapter, p::Vector{RealT}, t::RealT, fsptol::RealT) where {RealT <: AbstractFloat}\n\nMake the state space and solution vector ready for FSP integration.\n\n\n\n\n\n","category":"method"},{"location":"api/cmesolve/#FSP-output-format","page":"Transient solution of the CME","title":"FSP output format","text":"","category":"section"},{"location":"api/cmesolve/","page":"Transient solution of the CME","title":"Transient solution of the CME","text":"Modules = [NumCME]\nPages = [        \n        \"fspoutput.jl\"\n]","category":"page"},{"location":"api/cmesolve/#NumCME.FspOutputSliceSparse","page":"Transient solution of the CME","title":"NumCME.FspOutputSliceSparse","text":"struct FspOutputSliceSparse\n\nStruct to store the FSP solution at a single time. Fields: t, p, sinks.\n\n\n\n\n\n","category":"type"},{"location":"api/cmesolve/#NumCME.FspOutputSparse","page":"Transient solution of the CME","title":"NumCME.FspOutputSparse","text":"struct FspOutputSparse{NS, IntT<:Integer, RealT<:AbstractFloat}\n\nStruct to store Finite State Projection outputs based on the sparse representation of the FSP solution.\n\nFields\n\nt: Array of solution output times.\np: Array of FspVectorSparse instances. p[i] is the solution at time t[i].\nsinks: Probability mass accumulated at the sink states over time. \n\nUsage\n\nIf sol is of type FspOutputSparse, sol[i] will return a slice, of type FspOutputSliceSparse of the solution set at the i-th index. \n\nSee also\n\nFspOutputSliceSparse, length(::FspOutputSparse).\n\n\n\n\n\n","category":"type"},{"location":"api/cmesolve/#Base.length-Tuple{FspOutputSparse}","page":"Transient solution of the CME","title":"Base.length","text":"length(fspoutput::FspOutputSparse) -> Int64\n\n\nReturn number of FSP solutions in the solution set.\n\n\n\n\n\n","category":"method"},{"location":"api/cmesolve/#solve()-method","page":"Transient solution of the CME","title":"solve() method","text":"","category":"section"},{"location":"api/cmesolve/","page":"Transient solution of the CME","title":"Transient solution of the CME","text":"Modules = [NumCME]\nPages = [\n    \"transientcme/sparse/fspsolve.jl\"\n]\nsolve","category":"page"},{"location":"api/cmesolve/#CommonSolve.solve-Union{Tuple{RealT}, Tuple{IntT}, Tuple{NS}, Tuple{CmeModel, FspVectorSparse{NS, IntT, RealT}, Tuple{AbstractFloat, AbstractFloat}, AdaptiveFspSparse}} where {NS, IntT<:Integer, RealT<:AbstractFloat}","page":"Transient solution of the CME","title":"CommonSolve.solve","text":"solve(model::CmeModel, initial_distribution::FspVectorSparse{NS, IntT<:Integer, RealT<:AbstractFloat}, tspan::Tuple{AbstractFloat, AbstractFloat}, fspalgorithm::AdaptiveFspSparse; saveat, fsptol, odeatol, odertol, verbose) -> Any\n\n\nNumerical integration for the chemical master equation using an adaptive Finite State Projection (FSP) algorithm. This method is adaptive, meaning that states will be added during the course of integration to ensure the approximation error is below the user-specified tolerance.  In addition, depending on the input fspalgorithm, the space adapter may delete states with low probabilities before expanding the state space. This ensures not only accuracy but also efficiency of the CME integration.\n\nArguments\n\nmodel::CmeModel\n\nChemical Master Equation model.\n\ninitial_distribution::FspVectorSparse\n\nInitial distribution.\n\ntspan::Tuple{AbstractFloat, AbstractFloat}\n\nTimespan for the integration. The first element is the starting time, the second element is the end time of the integration.\n\nfspalgorithm::AdaptiveFspSparse\n\nAn instance of AdaptiveFspSparse, storing information about the specific adaptive FSP method.\n\nsaveat::Vector{AbstractFloat} (optional)\n\nTime points to store the FSP solutions at. Default is [], which means all solutions at every timestep will be stored.\n\nfsptol (optional)\n\nFSP truncation error tolerance. The FSP state space is adapted so that the output solution vectors sum to greater than or equal to 1-fsptol. Default: 1.0E-6.\n\nodertol (optional)\n\nRelative error tolerance for the ODE solver of the ODEs resulting from FSP truncation. Default: 1.0E-4.\n\nodeatol (optional)\n\nRelative error tolerance for the ODE solver of the ODEs resulting from FSP truncation. Default: 1.0E-10.\n\nverbose (optional)\n\nWhether to output status when updating the state space. Default: false.\n\nReturns\n\nAn instance of FspOutputSparse.\n\nSee also\n\nCmeModel, AdaptiveFspSparse, FspOutputSparse.\n\n\n\n\n\n","category":"method"}]
}
